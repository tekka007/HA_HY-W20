--- a/const.py
+++ b/const.py
@@ -17,6 +17,10 @@
 DEFAULT_TZ = "+01:00"
 DEFAULT_UPDATE_INTERVAL = 30
 
+# Update interval bounds (seconds)
+MIN_UPDATE_INTERVAL = 10
+MAX_UPDATE_INTERVAL = 3600
+
 # API paths
 CONF_CLOUD_DEFAULT = "https://cloudde.heyitech.com:8038/hysoft"
 LOGIN_PATH = "/puserlogin.shtml"
@@ -31,4 +35,4 @@
 # Command controlType values (writes)
 CMD_DISARM = 3   # NOTE: disarm uses 3 on control endpoint (special case)
 CMD_ARMED = 1
 CMD_HOME = 2
--- a/config_flow.py
+++ b/config_flow.py
@@ -9,7 +9,8 @@
 from .const import (
     DOMAIN,
     CONF_USERNAME, CONF_PASSWORD, CONF_BASE_URL, CONF_DEVICE_ID, CONF_CLOUD_DEFAULT,
     CONF_TIMEZONE, CONF_LANG, CONF_TERMINAL, CONF_UPDATE_INTERVAL,
-    DEFAULT_TZ, DEFAULT_LANG, DEFAULT_TERMINAL, DEFAULT_UPDATE_INTERVAL,
+    DEFAULT_TZ, DEFAULT_LANG, DEFAULT_TERMINAL, DEFAULT_UPDATE_INTERVAL,
+    MIN_UPDATE_INTERVAL, MAX_UPDATE_INTERVAL,
 )
 
 class HeyitechConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
@@ -17,7 +18,7 @@
 
     async def async_step_user(self, user_input=None) -> FlowResult:
         if user_input is not None:
-            await self.async_set_unique_id(user_input[CONF_BASE_URL].rstrip("/"))
+            await self.async_set_unique_id(f"{user_input[CONF_BASE_URL].rstrip('/')}_{user_input[CONF_DEVICE_ID]}")
             self._abort_if_unique_id_configured()
             return self.async_create_entry(title="Heyitech Alarm", data=user_input)
 
@@ -28,7 +29,11 @@
             vol.Required(CONF_DEVICE_ID): str,
             vol.Optional(CONF_TIMEZONE, default=DEFAULT_TZ): str,
             vol.Optional(CONF_LANG, default=DEFAULT_LANG): str,
             vol.Optional(CONF_TERMINAL, default=DEFAULT_TERMINAL): str,
-            vol.Optional(CONF_UPDATE_INTERVAL, default=DEFAULT_UPDATE_INTERVAL): int,
+            vol.Optional(
+                CONF_UPDATE_INTERVAL,
+                default=DEFAULT_UPDATE_INTERVAL,
+            ): vol.All(vol.Coerce(int), vol.Range(min=MIN_UPDATE_INTERVAL, max=MAX_UPDATE_INTERVAL)),
         })
         return self.async_show_form(step_id="user", data_schema=schema)
 
@@ -49,7 +54,11 @@
 
         opts = self._entry.options
         schema = vol.Schema({
-            vol.Optional(CONF_UPDATE_INTERVAL, default=opts.get(CONF_UPDATE_INTERVAL, DEFAULT_UPDATE_INTERVAL)): int,
+            vol.Optional(
+                CONF_UPDATE_INTERVAL,
+                default=opts.get(CONF_UPDATE_INTERVAL, DEFAULT_UPDATE_INTERVAL),
+            ): vol.All(vol.Coerce(int), vol.Range(min=MIN_UPDATE_INTERVAL, max=MAX_UPDATE_INTERVAL)),
         })
         return self.async_show_form(step_id="init", data_schema=schema)
--- a/coordinator.py
+++ b/coordinator.py
@@ -13,7 +13,7 @@
 )
 from .api import HeyitechClient, HeyitechApiError
 from .const import DEFAULT_LANG, DEFAULT_TERMINAL, DEFAULT_TZ
-from .const import DEFAULT_UPDATE_INTERVAL, CONF_UPDATE_INTERVAL
+from .const import DEFAULT_UPDATE_INTERVAL, CONF_UPDATE_INTERVAL, MIN_UPDATE_INTERVAL, MAX_UPDATE_INTERVAL
 
 _LOGGER = logging.getLogger(__name__)
 
@@ -31,7 +31,8 @@
         self.lang = cfg.get(CONF_LANG, DEFAULT_LANG)
         self.terminal = cfg.get(CONF_TERMINAL, DEFAULT_TERMINAL)
         self.tz = cfg.get(CONF_TIMEZONE, DEFAULT_TZ)
-        interval = cfg.get(CONF_UPDATE_INTERVAL, DEFAULT_UPDATE_INTERVAL)
+        interval = int(cfg.get(CONF_UPDATE_INTERVAL, DEFAULT_UPDATE_INTERVAL))
+        interval = max(MIN_UPDATE_INTERVAL, min(MAX_UPDATE_INTERVAL, interval))
 
         session = async_get_clientsession(hass)
         self.client = HeyitechClient(session, self.base_url)
--- a/__init__.py
+++ b/__init__.py
@@ -7,7 +7,7 @@
 
 from .const import DOMAIN, PLATFORMS
 from .coordinator import HeyitechCoordinator
-from .const import CONF_UPDATE_INTERVAL
+from .const import CONF_UPDATE_INTERVAL, MIN_UPDATE_INTERVAL, MAX_UPDATE_INTERVAL
 
 
 async def async_setup(hass: HomeAssistant, config: ConfigType):
@@ -43,8 +43,9 @@
 
 async def _updated(hass: HomeAssistant, entry: ConfigEntry):
     coord = hass.data[DOMAIN][entry.entry_id]
-    interval = entry.options.get(CONF_UPDATE_INTERVAL, coord.update_interval.total_seconds())
-    coord.update_interval = timedelta(seconds=int(interval))
+    interval = int(entry.options.get(CONF_UPDATE_INTERVAL, coord.update_interval.total_seconds()))
+    interval = max(MIN_UPDATE_INTERVAL, min(MAX_UPDATE_INTERVAL, interval))
+    coord.update_interval = timedelta(seconds=interval)
     await coord.async_request_refresh()
 
--- a/api.py
+++ b/api.py
@@ -1,6 +1,7 @@
 from __future__ import annotations
 
+import asyncio
 import json
 import logging
 from typing import Any, Dict
 
@@ -28,6 +29,31 @@
     def __init__(self, session: aiohttp.ClientSession, base_url: str) -> None:
         self._session = session
         self._base = base_url.rstrip("/")
+
+    @staticmethod
+    def _validate_response(body: Any, context: str) -> None:
+        """Raise HeyitechApiError when the API body clearly indicates failure."""
+        if not isinstance(body, dict):
+            return
+
+        # Common patterns across similar cloud APIs
+        if body.get("success") is False:
+            raise HeyitechApiError(f"{context} failed: {body.get('msg') or body.get('message') or body}")
+
+        for key in ("code", "resultCode", "ret", "status"):
+            if key not in body:
+                continue
+            val = body.get(key)
+            # Treat 0/200/"0"/"200"/True as success.
+            if val in (0, 200, "0", "200", True):
+                return
+            # If it looks like an error code, raise with best-effort message.
+            if val is not None and str(val) not in ("0", "200", "True"):
+                msg = body.get("msg") or body.get("message") or body.get("resultMsg") or body.get("error") or body
+                raise HeyitechApiError(f"{context} failed ({key}={val}): {msg}")
 
     async def _login(self, username: str, password: str, terminal: str, lang: str, tz: str) -> str:
         url = f"{self._base}{LOGIN_PATH}"
@@ -39,6 +65,7 @@
         headers = {"Content-Type": "application/x-www-form-urlencoded"}
 
         _LOGGER.debug("Heyitech login POST %s", url)
+        context = "login"
         try:
             async with async_timeout.timeout(15):
                 async with self._session.post(url, data=data, headers=headers) as resp:
@@ -46,10 +73,13 @@
                     text = await resp.text()
                     if resp.status != 200:
                         raise HeyitechAuthError(f"HTTP {resp.status}: {text}")
                     body = await resp.json(content_type=None)
-        except aiohttp.ClientError as err:
-            raise HeyitechApiError(f"Network error during login: {err}") from err
+                    self._validate_response(body, context)
+        except asyncio.TimeoutError as err:
+            raise HeyitechApiError(f"Timeout during {context}: {err}") from err
+        except aiohttp.ClientError as err:
+            raise HeyitechApiError(f"Network error during {context}: {err}") from err
 
         token = body.get("tokenId")
         if not token:
@@ -77,6 +107,7 @@
         headers = {"Content-Type": "application/x-www-form-urlencoded"}
 
         _LOGGER.debug("Heyitech get_arm_status POST %s (device %s)", url, device_id)
+        context = "get_arm_status"
         try:
             async with async_timeout.timeout(15):
                 async with self._session.post(url, data=data, headers=headers) as resp:
@@ -84,9 +115,13 @@
                     text = await resp.text()
                     if resp.status != 200:
                         raise HeyitechApiError(f"HTTP {resp.status}: {text}")
-                    return await resp.json(content_type=None)
-        except aiohttp.ClientError as err:
-            raise HeyitechApiError(f"Network error during get_arm_status: {err}") from err
+                    body = await resp.json(content_type=None)
+                    self._validate_response(body, context)
+                    return body
+        except asyncio.TimeoutError as err:
+            raise HeyitechApiError(f"Timeout during {context}: {err}") from err
+        except aiohttp.ClientError as err:
+            raise HeyitechApiError(f"Network error during {context}: {err}") from err
 
     async def remote_control(
         self,
@@ -111,6 +146,7 @@
         _LOGGER.debug(
             "Heyitech remote_control POST %s (device %s, controlType %s)",
             url, device_id, control_type
         )
+        context = "remote_control"
         try:
             async with async_timeout.timeout(15):
                 async with self._session.post(url, data=data, headers=headers) as resp:
@@ -118,7 +154,12 @@
                     text = await resp.text()
                     if resp.status != 200:
                         raise HeyitechApiError(f"HTTP {resp.status}: {text}")
-                    return await resp.json(content_type=None)
-        except aiohttp.ClientError as err:
-            raise HeyitechApiError(f"Network error during remote_control: {err}") from err
+                    body = await resp.json(content_type=None)
+                    self._validate_response(body, context)
+                    return body
+        except asyncio.TimeoutError as err:
+            raise HeyitechApiError(f"Timeout during {context}: {err}") from err
+        except aiohttp.ClientError as err:
+            raise HeyitechApiError(f"Network error during {context}: {err}") from err
--- a/alarm_control_panel.py
+++ b/alarm_control_panel.py
@@ -42,17 +42,18 @@
     ent = HeyitechAlarmEntity(coord, entry)
     async_add_entities([ent], True)
 
     # Register a raw pass-through service for testing/debugging
-    # Note: 0 (status code) is intentionally excluded; only valid write commands 1, 2, 3 are allowed.
-    platform = async_get_current_platform()
-    platform.async_register_entity_service(
-        "set_raw_state",
-        {vol.Required("state"): vol.In([1, 2, 3])},
-        "async_set_raw_state",
-    )
+    # Only register in debug mode to avoid exposing foot-guns in production.
+    if hass.config.debug:
+        platform = async_get_current_platform()
+        platform.async_register_entity_service(
+            "set_raw_state",
+            {vol.Required("state"): vol.In([1, 2, 3])},
+            "async_set_raw_state",
+        )
 
 
 class HeyitechAlarmEntity(CoordinatorEntity[HeyitechCoordinator], AlarmControlPanelEntity):
@@ -69,6 +70,18 @@
         super().__init__(coordinator)
         self._entry = entry
         self._attr_unique_id = f"{entry.entry_id}_alarm"
+
+    @property
+    def device_info(self) -> dict[str, Any]:
+        """Return device registry information."""
+        device_id = self._entry.data.get("device_id")
+        return {
+            "identifiers": {(DOMAIN, str(device_id))},
+            "name": f"Heyitech Alarm {device_id}",
+            "manufacturer": "Heyitech",
+            "model": "Alarm Panel",
+        }
 
     @property
     def code_format(self):
@@ -84,13 +97,15 @@
 
     @property
     def extra_state_attributes(self) -> Dict[str, Any]:
         d = self.coordinator.data or {}
-        return {
-            "device_id": self._entry.data.get("device_id"),
-            "arm_level_raw": d.get("value"),
-            "raw": d,
-        }
+        attrs = {
+            "device_id": self._entry.data.get("device_id"),
+            "arm_level_raw": d.get("value"),
+        }
+        if self.hass is not None and self.hass.config.debug:
+            attrs["raw"] = d
+        return attrs
